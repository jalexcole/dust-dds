module dds { module xrce {

    typedef octet ClientKey[4];

// IDL does not have a syntax to express array constants so we
// use #define with is legal in IDL
#define CLIENTKEY_INVALID {0x00, 0x00, 0x00, 0x00}

    typedef octet ObjectKind;

    const ObjectKind OBJK_INVALID     = 0x00;
    const ObjectKind OBJK_PARTICIPANT = 0x01;
    const ObjectKind OBJK_TOPIC       = 0x02;
    const ObjectKind OBJK_PUBLISHER   = 0x03;
    const ObjectKind OBJK_SUBSCRIBER  = 0x04;
    const ObjectKind OBJK_DATAWRITER  = 0x05;
    const ObjectKind OBJK_DATAREADER  = 0x06;
    const ObjectKind OBJK_TYPE        = 0x0A;
    const ObjectKind OBJK_QOSPROFILE  = 0x0B;
    const ObjectKind OBJK_APPLICATION = 0x0C;
    const ObjectKind OBJK_AGENT       = 0x0D;
    const ObjectKind OBJK_CLIENT      = 0x0E;
    const ObjectKind OBJK_OTHER       = 0x0F;

    typedef octet ObjectId     [2];
    typedef octet ObjectPrefix [2];

    // There are three predefined values ObjectId
    // IDL does not have a syntax to express array constants so we
    // use #define with is legal in IDL
#define  OBJECTID_INVALID {0x00,0x00}
#define  OBJECTID_AGENT   {0xFF,0xFD}
#define  OBJECTID_CLIENT  {0xFF,0xFE}
#define  OBJECTID_SESSION {0xFF,0xFF}

    typedef octet XrceCookie[4];
    // Spells ‘X’ ‘R’ ‘C’ ‘E’
#define XRCE_COOKIE { 0x58, 0x52, 0x43, 0x45 }

    typedef octet XrceVersion[2];
#define XRCE_VERSION_MAJOR     0x01
#define XRCE_VERSION_MINOR     0x00
#define XRCE_VERSION  { XRCE_VERSION_MAJOR, XRCE_VERSION_MINOR }

    typedef octet XrceVendorId[2];
#define XRCE_VENDOR_INVALID1  0x00
#define XRCE_VENDOR_INVALID1  0x00


    struct Time_t {
        long           seconds;
        unsigned long  nanoseconds;
    };

    typedef octet SessionId;
    const SessionId SESSIONID_NONE_WITH_CLIENT_KEY     = 0x00;
    const SessionId SESSIONID_NONE_WITHOUT_CLIENT_KEY  = 0x80;

    typedef octet StreamId;
    const StreamId STREAMID_NONE                        = 0x00;
    const StreamId STREAMID_BUILTIN_BEST_EFFORTS        = 0x01;
    const StreamId STREAMID_BUILTIN_RELIABLE            = 0x80;

    @bit_bound(8)
    enum TransportLocatorFormat {
        ADDRESS_FORMAT_SMALL,
        ADDRESS_FORMAT_MEDIUM,
        ADDRESS_FORMAT_LARGE,
        ADDRESS_FORMAT_STRING
    };

    struct TransportLocatorSmall {
        octet address[2];
        octet locator_port;
    };
    struct TransportLocatorMedium {
        octet address[4];
        unsigned short locator_port;
    };
    struct TransportLocatorLarge {
        octet address[16];
        unsigned long locator_port;
    };
    struct TransportLocatorString {
        string value;
    };

    union TransportLocator switch (TransportLocatorFormat) {
        case ADDRESS_FORMAT_SMALL:
        TransportLocatorSmall small_locator;
        case ADDRESS_FORMAT_MEDIUM:
        TransportLocatorMedium medium_locator;
        case ADDRESS_FORMAT_LARGE:
        TransportLocatorLarge medium_locator;
        case ADDRESS_FORMAT_STRING:
        TransportLocatorString string_locator;
    };
    typedef sequence<TransportLocator> TransportLocatorSeq;

    struct Property {
        string name;
        string value;
    };
    typedef sequence<Property> PropertySeq;

    @extensibility(FINAL)
    struct CLIENT_Representation {
        XrceCookie   xrce_cookie;  // XRCE_COOKIE
        XrceVersion  xrce_version;
        XrceVendorId xrce_vendor_id;

        ClientKey    client_key;
        SessionId    session_id;
        @optional  PropertySeq properties;
    };

    @extensibility(FINAL)
    struct AGENT_Representation {
        XrceCookie   xrce_cookie;  // XRCE_COOKIE
        XrceVersion  xrce_version;
        XrceVendorId xrce_vendor_id;
        @optional  PropertySeq  properties;
    };

    typedef octet RepresentationFormat;
    const RepresentationFormat REPRESENTATION_BY_REFERENCE  = 0x01;
    const RepresentationFormat REPRESENTATION_AS_XML_STRING = 0x02;
    const RepresentationFormat REPRESENTATION_IN_BINARY     = 0x03;

    const long REFERENCE_MAX_LEN  = 128;

    @extensibility(FINAL)
    union OBJK_Representation3Formats switch(RepresentationFormat) {
      case REPRESENTATION_BY_REFERENCE :
        string<REFERENCE_MAX_LEN>  object_reference;
      case REPRESENTATION_AS_XML_STRING :
        string           xml_string_representation;
      case REPRESENTATION_IN_BINARY :
        sequence<octet>  binary_representation;
    };

    @extensibility(FINAL)
    union OBJK_RepresentationRefAndXMLFormats switch(RepresentationFormat) {
      case REPRESENTATION_BY_REFERENCE :
        string<REFERENCE_MAX_LEN>  object_reference;
      case REPRESENTATION_AS_XML_STRING :
        string           string_representation;
    };

    @extensibility(FINAL)
    union OBJK_RepresentationBinAndXMLFormats switch(RepresentationFormat) {
      case REPRESENTATION_IN_BINARY :
        sequence<octet>  binary_representation;
      case REPRESENTATION_AS_XML_STRING :
        string           string_representation;
    };

    @extensibility(FINAL)
    struct OBJK_RepresentationRefAndXML_Base {
      OBJK_RepresentationRefAndXMLFormats representation;
    };

    @extensibility(FINAL)
    struct OBJK_RepresentationBinAndXML_Base {
      OBJK_RepresentationBinAndXMLFormats representation;
    };

    @extensibility(FINAL)
    struct OBJK_Representation3_Base {
      OBJK_Representation3Formats representation;
    };

    /* Objects supporting by Reference and XML formats */

    @extensibility(FINAL)
    struct OBJK_QOSPROFILE_Representation : OBJK_RepresentationRefAndXML_Base {
    };

    @extensibility(FINAL)
    struct OBJK_TYPE_Representation       : OBJK_RepresentationRefAndXML_Base {
    };

    @extensibility(FINAL)
    struct OBJK_DOMAIN_Representation : OBJK_RepresentationRefAndXML_Base {
    };

    @extensibility(FINAL)
    struct OBJK_APPLICATION_Representation : OBJK_RepresentationRefAndXML_Base {
    };


    /* Objects supporting Binary and XML formats */
    @extensibility(FINAL)
    struct OBJK_PUBLISHER_Representation   : OBJK_RepresentationBinAndXML_Base {
        ObjectId participant_id;
    };

    @extensibility(FINAL)
    struct OBJK_SUBSCRIBER_Representation : OBJK_RepresentationBinAndXML_Base {
        ObjectId participant_id;
    };

    @extensibility(FINAL)
    struct DATAWRITER_Representation    : OBJK_RepresentationBinAndXML_Base {
        ObjectId publisher_id;
    };

    @extensibility(FINAL)
    struct DATAREADER_Representation    : OBJK_RepresentationBinAndXML_Base {
        ObjectId subscriber_id;
    };

    /* Objects supporting all 3 representation formats */
    @extensibility(FINAL)
    struct OBJK_PARTICIPANT_Representation : OBJK_Representation3_Base {
        short     domain_id;
    };

    @extensibility(FINAL)
    struct OBJK_TOPIC_Representation : OBJK_Representation3_Base {
        ObjectId participant_id;
    };


    /* Binary representations */
    @extensibility(APPENDABLE)
    struct  OBJK_DomainParticipant_Binary {
        @optional string<128> domain_reference;
        @optional string<128> qos_profile_reference;
    };

    @extensibility(APPENDABLE)
    struct  OBJK_Topic_Binary {
        string<256> topic_name;
        @optional string<256> type_reference;
        @optional DDS:XTypes::TypeIdentifier type_identifier;
    };

    @extensibility(FINAL)
    struct  OBJK_Publisher_Binary_Qos {
        @optional sequence<string>  partitions;
        @optional sequence<octet>   group_data;
    };

    @extensibility(APPENDABLE)
    struct  OBJK_Publisher_Binary {
        @optional string publisher_name;
        @optional OBJK_Publisher_Binary_Qos  qos;
    };

    @extensibility(FINAL)
    struct  OBJK_Subscriber_Binary_Qos {
        @optional sequence<string>  partitions;
        @optional sequence<octet>   group_data;
    };

    @extensibility(APPENDABLE)
    struct  OBJK_Subscriber_Binary {
        @optional string subscriber_name;
        @optional OBJK_Subscriber_Binary_Qos  qos;
    };

    @bit_bound(16)
    bitmask EndpointQosFlags {
        @position(0) is_reliable,
        @position(1) is_history_keep_all,
        @position(2) is_ownership_exclusive,
        @position(3) is_durability_transient_local,
        @position(4) is_durability_transient,
        @position(5) is_durability_persistent,
    };

    @extensibility(FINAL)
    struct  OBJK_Endpoint_Binary_Qos {
        EndpointQosFlags            qos_flags;
        @optional unsigned short    history_depth;
        @optional unsigned long     deadline_msec;
        @optional unsigned long     lifespan_msec;
        @optional sequence<octet>   user_data;
    };

    @extensibility(FINAL)
    struct  OBJK_DataWriter_Binary_Qos :  OBJK_Endpoint_Binary_Qos {
        @optional unsigned long     ownership_strength;
    };

    @extensibility(FINAL)
    struct  OBJK_DataReader_Binary_Qos :  OBJK_Endpoint_Binary_Qos {
        @optional unsigned long     timebasedfilter_msec;
        @optional string            contentbased_filter;
   };

    @extensibility(APPENDABLE)
    struct  OBJK_DataReader_Binary {
        string                                  topic_name;
        @optional OBJK_DataReader_Binary_Qos    qos;
    };

    @extensibility(APPENDABLE)
    struct  OBJK_DataWriter_Binary {
        string                               topic_name;
        @optonal OBJK_DataWriter_Binary_Qos  qos;
    };

    @extensibility(FINAL)
    union ObjectVariant switch(ObjectKind) {
      // case OBJK_INVALID : indicates default or selected by Agent. No data.
    case OBJK_AGENT :
      AGENT_Representation client;
    case OBJK_CLIENT :
      CLIENT_Representation client;
    case OBJK_APPLICATION :
      OBJK_APPLICATION_Representation application;
    case OBJK_PARTICIPANT :
      OBJK_PARTICIPANT_Representation participant;
    case OBJK_QOSPROFILE :
      OBJK_QOSPROFILE_Representation qos_profile;
    case OBJK_TYPE :
      OBJK_TYPE_Representation type;
    case OBJK_TOPIC :
      OBJK_TOPIC_Representation topic;
    case OBJK_PUBLISHER :
      OBJK_PUBLISHER_Representation publisher;
    case OBJK_SUBSCRIBER :
      OBJK_SUBSCRIBER_Representation subscriber;
    case OBJK_DATAWRITER :
      DATAWRITER_Representation data_writer;
    case OBJK_DATAREADER :
      DATAREADER_Representation data_reader;
    };

    struct CreationMode {
      boolean reuse;
      boolean replace;
    };


    typedef octet RequestId[2];

    @bit_bound(8)
    enum StatusValue {
        @value(0x00) STATUS_OK,
        @value(0x01) STATUS_OK_MATCHED,
        @value(0x80) STATUS_ERR_DDS_ERROR,
        @value(0x81) STATUS_ERR_MISMATCH,
        @value(0x82) STATUS_ERR_ALREADY_EXISTS,
        @value(0x83) STATUS_ERR_DENIED,
        @value(0x84) STATUS_ERR_UNKNOWN_REFERENCE,
        @value(0x85) STATUS_ERR_INVALID_DATA,
        @value(0x86) STATUS_ERR_INCOMPATIBLE,
        @value(0x87) STATUS_ERR_RESOURCES
    };

    struct ResultStatus {
      StatusValue  status;
      octet        implementation_status;
    };

    bitmask InfoMask {
      @position(0) INFO_CONFIGURATION,
      @position(1) INFO_ACTIVITY
    };

    @extensibility(APPENDABLE)
    struct AGENT_ActivityInfo {
        short availability;
        TransportLocatorSeq address_seq;
    };

    @extensibility(APPENDABLE)
    struct DATAREADER_ActivityInfo {
        short highest_acked_num;
    };

    @extensibility(APPENDABLE)
    struct DATAWRITER_ActivityInfo {
        unsigned long long sample_seq_num;
        short stream_seq_num;
    };

    @extensibility(FINAL)
    union ActivityInfoVariant switch (ObjectKind) {
      case OBJECTID_AGENT :
        AGENT_ActivityInfo  agent;
      case OBJK_DATAWRITER :
        DATAWRITER_ActivityInfo data_writer;
      case OBJK_DATAREADER :
        DATAREADER_ActivityInfo data_reader;
    };

    @extensibility(FINAL)
    struct ObjectInfo {
        @optional  ActivityInfoVariant  activity;
        @optional  ObjectVariant        config;
    };

    @extensibility(FINAL)
    struct BaseObjectRequest {
      RequestId     request_id;
      ObjectId      object_id;
    };

    typedef RelatedObjectRequest BaseObjectRequest;

    @extensibility(FINAL)
    struct BaseObjectReply {
      BaseObjectRequest  related_request;
      ResultStatus       result;
    };

    typedef octet DataFormat;
    const DataFormat FORMAT_DATA           = 0x00; // 0b0000 0000
    const DataFormat FORMAT_SAMPLE         = 0x02; // 0b0000 0010
    const DataFormat FORMAT_DATA_SEQ       = 0x08; // 0b0000 1000
    const DataFormat FORMAT_SAMPLE_SEQ     = 0x0A; // 0b0000 1010
    const DataFormat FORMAT_PACKED_SAMPLES = 0x0E; // 0b0000 1110
    const DataFormat FORMAT_MASK           = 0x0E; // 0b0000 1110

    @extensibility(APPENDABLE)
    struct DataDeliveryControl {
        unsigned short max_samples;
        unsigned short max_elapsed_time;
        unsigned short max_bytes_per_second;
        unsigned short min_pace_period;  // milliseconds
    };

    @extensibility(FINAL)
    struct ReadSpecification  {
        StreamId    preferred_stream_id;
        DataFormat data_format;
        @optional string              content_filter_expression;
        @optional DataDeliveryControl delivery_control;
    };

    @bit_bound(8)
    bitmask SampleInfoFlags {
        @position(0) INSTANCE_STATE_UNREGISTERED,
        @position(1) INSTANCE_STATE DISPOSED,
        @position(2) VIEW_STATE_NEW,
        @position(3) SAMPLE_STATE_READ,
    };

    typedef octet SampleInfoFormat;
    const SampleInfoFormat FORMAT_EMPTY      = 0x00; // 0b0000 0000
    const SampleInfoFormat FORMAT_SEQNUM     = 0x01; // 0b0000 0001
    const SampleInfoFormat FORMAT_TIMESTAMP  = 0x02; // 0b0000 0010
    const SampleInfoFormat FORMAT_SEQN_TIMS  = 0x03; // 0b0000 0011

    @extensibility(FINAL)
    struct SeqNumberAndTimestamp {
        unsigned long   sequence_number;
        unsigned long   session_time_offset; // milliseconds up to 53 days
    };

    @extensibility(FINAL)
    union SampleInfoDetail switch(SampleInfoFormat) {
      case FORMAT_EMPTY:
      case FORMAT_SEQNUM:
        unsigned long   sequence_number;
      case FORMAT_TIMESTAMP:
        unsigned long   session_time_offset; // milliseconds up to 53 days
      case FORMAT_TIMESTAMP:
        SeqNumberAndTimestamp seqnum_n_timestamp;
    };

    @extensibility(FINAL)
    struct SampleInfo {
        SampleInfoFlags  state; //Combines SampleState, InstanceState, ViewState
        SampleInfoDetail detail;
    };

    typedef unsigned short  DeciSecond; // 10e-1 seconds
    @extensibility(FINAL)
    struct SampleInfoDelta {
      SampleInfoFlags state;  // Combines SampleState, InstanceState, ViewState
      octet           seq_number_delta;
      DeciSecond      timestamp_delta; // In 1/10 of seconds
    };

    @extensibility(FINAL)
    struct SampleData {
        XCDRSerializedBuffer serialized_data;
    };
    typedef sequence<SampleData> SampleDataSeq;

    @extensibility(FINAL)
    struct Sample {
      SampleInfo   info;
      SampleData   data;
    };
    typedef sequence<Sample> SampleSeq;

    @extensibility(FINAL)
    struct SampleDelta {
      SampleInfoDelta   info_delta;
      SampleData        data;
    };

    @extensibility(FINAL)
    struct PackedSamples {
      SampleInfo             info_base;
      sequence<SampleDelta>  sample_delta_seq;
    };

    @extensibility(FINAL)
    union DataRepresentation switch(DataFormat) {
      case FORMAT_DATA:
        SampleData data;
      case FORMAT_SAMPLE:
        Sample sample;
      case FORMAT_DATA_SEQ:
        SampleDataSeq data_seq;
      case FORMAT_SAMPLE_SEQ:
        SampleSeq sample_seq;
      case FORMAT_PACKED_SAMPLES:
        PackedSamples packed_samples;
    };

    // Message Payloads
    @extensibility(FINAL)
    struct CREATE_CLIENT_Payload {
        CLIENT_Representation client_representation;
    };

    @extensibility(FINAL)
    struct CREATE_Payload : BaseObjectRequest {
        ObjectVariant  object_representation;
    };

    @extensibility(FINAL)
    struct GET_INFO_Payload : BaseObjectRequest {
        InfoMask  info_mask;
    };

    @extensibility(FINAL)
    struct DELETE_Payload : BaseObjectRequest {
    };

    @extensibility(FINAL)
    struct STATUS_AGENT_Payload {
        AGENT_Representation agent_info;
    };

    @extensibility(FINAL)
    struct STATUS_Payload : BaseObjectReply {
    };

    @extensibility(FINAL)
    struct INFO_Payload : BaseObjectReply {
        ObjectInfo     object_info;
    };

    @extensibility(FINAL)
    struct READ_DATA_Payload : BaseObjectRequest {
        ReadSpecification                read_specification;
    };

    // There are 5 types of DATA and WRITE_DATA payloads
    @extensibility(FINAL)
    struct WRITE_DATA_Payload_Data : BaseObjectRequest {
        SampleData              data;
    };

    @extensibility(FINAL)
    struct WRITE_DATA_Payload_Sample : BaseObjectRequest {
        Sample                sample;
    };

    @extensibility(FINAL)
    struct WRITE_DATA_Payload_DataSeq : BaseObjectRequest {
        SampleDataSeq           data_seq;
    };

    @extensibility(FINAL)
    struct WRITE_DATA_Payload_SampleSeq : BaseObjectRequest {
        SampleSeq               sample_seq;
    };

    @extensibility(FINAL)
    struct WRITE_DATA_Payload_PackedSamples : BaseObjectRequest {
        PackedSamples           packed_samples;
    };

    @extensibility(FINAL)
    struct DATA_Payload_Data : RelatedObjectRequest {
        SampleData              data;
    };

    @extensibility(FINAL)
    struct DATA_Payload_Sample : RelatedObjectRequest {
          Sample                sample;
    };

    @extensibility(FINAL)
    struct DATA_Payload_DataSeq : RelatedObjectRequest {
        SampleDataSeq           data_seq;
    };

    @extensibility(FINAL)
    struct DATA_Payload_SampleSeq : RelatedObjectRequest {
        SampleSeq               sample_seq;
    };

    @extensibility(FINAL)
    struct DATA_Payload_PackedSamples : RelatedObjectRequest {
        PackedSamples           packed_samples;
    };

    struct ACKNACK_Payload {
        unsigned short  first_unacked_seq_num;
        octet           nack_bitmap[2];
        octet           stream_id;
    };

    @extensibility(FINAL)
    struct HEARTBEAT_Payload {
        unsigned short  first_unacked_seq_num;
        unsigned short  last_unacked_seq_num;
        octet           stream_id;
    };

    @extensibility(FINAL)
    struct TIMESTAMP_Payload {
        Time_t  transmit_timestamp;
    };

    @extensibility(FINAL)
    struct TIMESTAMP_REPLY_Payload {
        Time_t  transmit_timestamp;
        Time_t  receive_timestamp;
        Time_t  originate_timestamp;
    };

    @bit_bound(8)
    enum SubmessageId {
        @value(0)  CREATE_CLIENT,
        @value(1)  CREATE,
        @value(2)  GET_INFO,
        @value(3)  DELETE,
        @value(4)  STATUS_AGENT,
        @value(5)  STATUS,
        @value(6)  INFO,
        @value(7)  WRITE_DATA,
        @value(8)  READ_DATA,
        @value(9)  DATA,
        @value(10)  ACKNACK,
        @value(11) HEARTBEAT,
        @value(12) RESET,
        @value(13) FRAGMENT,
        @value(14) TIMESTAMP,
        @value(15) TIMESTAMP_REPLY
    };


  }; };

